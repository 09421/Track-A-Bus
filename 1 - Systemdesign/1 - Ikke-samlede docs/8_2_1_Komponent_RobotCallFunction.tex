\documentclass[Main.tex]{subfiles} 
\begin{document}

\subsubsection{Komponent 1: Sorteringsprogram}
Denne komponent indeholder funktioner, der udformer hovedprogrammet til at sortere klodserne. Denne komponent består hovedsageligt én klasse (RobotProgramFunctions). Da det er hovedfunktionen til sortering af klodserne der ligger i denne klasse, har klassen også mange afhængigheder til andre komponenter i systemet. 
\subsubsection*{Design} 
Som nævnt har RobotProgramFunctions mange afhængigheder til andre komponenter i systemet. Herunder ses et diagram, der giver et overblik over hvorledes afhængighederne ser ud (se det fulde overblik i \textit{afsnit 5: LOGISK VIEW}).
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{Diagrammer/Klassediagrammer/Klassediagrammer/JPGFiler/Pakke-RobotProgramFunctions.jpg} 
\caption{Klassediagram - RobotProgramFunctions}
\end{figure}
De seks afhængigheder, der går ud af pakken, er interfaces, som initieres med constructer injection. På den måde kan man skifte mellem rigtige objekter og fakeobjekter beregnet til simulering (\textit{se afsnit "7.2.2 Komponent 2: Simulering"}). 'IRoboCalls' afhængigheden er den der styrer, om programmet bliver kørt med rigtige funktioner fra USBC dll'en, eller om programmet simuleres med "falske" funktionskald.\\
Derudover har klassen et objekt af 'Brick', hvor information om klodserne gemmes midlertidigt.
\\

\subsubsection*{RobotEvent}
Før de forskellige funktioner dokumenteres, kræves en smule viden om klassen RobotEvent. Funktionerne i RobotProgramFunctions benytter klassen RobotEvent, til at tjekke om der er sket nogle events med robotten, såsom at en klods er ankommet til sensoren. Klassen indeholder tre bools, der bliver sat i de forskellige callbackfunktioner, der tilhører funktioner fra USBC dll'en (se afsnit \textit{2.4.1 USBC.dll}, for detaljeret dokumentation for USBC funktionskald). 
RobotEvent er en singleton, da det er vigtigt at der kun oprettes et objekt af denne klasse, da der jo kun er en robot, og eventene skal svarer til denne.

\subsubsection*{Funktioner}
Herunder findes beskrivelse af funktionerne i RobotProgramFunctions.\\\\
\textit{\textbf{RunConveyerBelt()}}\\
Herunder ses et lille sekvensdiagram over forløbet i funktionen:
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{Diagrammer/dSSD/RobotProgramFunctions/JPEGFiler/RunConveyerBelt.jpg}
\caption{Sekvensdiagram: RunConveyerBelt}
\end{figure}
Når denne funktion kaldes, starter den med at sætte en bool til false i RobotEvent, som betyder at der ikke er nogen klods foran sensoren. Derefter går funktionen ind i en while-løkke, der tjekker på RobotEvent boolen. Inde i denne sættes transportbåndet i bevægelse (det køre kun i en begrænset periode), hvorefter der er en sleep, der sørger for den ikke står og tager hele CPU'en. Denne bool bliver sat via en callbackfunktion fra funktionen WatchDigitalInp i USBC.dll, der bliver kaldt, når sensorværdien ændrer sig(se \textit{Se bilag: DLL filer/USBC.dll} for information om WatchDigitalInp). Dermed et det vigtigt at WatchDigitalInp er blevet kaldt, hvilket også bliver gjort i funktion SetupRobot(). Når den går ud af while-løkken, stoppes transportbåndet.
\\\\
\textit{\textbf{OpenCloseGripper(bool openClose)}}\\
Herunder ses et lille sekvensdiagram over forløbet i funktionen:
\begin{figure}[H]%[hbtp]
\centering
\includegraphics[scale=0.6]{Diagrammer/dSSD/RobotProgramFunctions/JPEGFiler/OpenCloseGripper.jpg}
\caption{Sekvensdiagram: OpenCloseGripper}
\end{figure}
Parameteren 'openClose' bestemmer om gripperen skal åbne eller lukke. Funktionen starter dog med at sætte en bool til true i RobotEvent, der siger at robotten er i bevægelse. Derefter åbnes eller lukkes gripperen via en USBC funktion. Funktioner går, ligesom RunConveyerBelt(), ind i en while-løkke med en kort sleep, for at skåne CPU'en, indtil boolen i RobotEvent ændrer sig. Denne bool bliver sat via en callbackfunktion fra funktionen WatchMotion i USBC.dll, der bliver kaldt, når robotten ikke bevæger sig mere (se \textit{se bilag DLL Filer/USBC.dll} for information om WatchMotion). Dermed et det vigtigt at WatchMotion bliver kaldt.\\\\
\textit{\textbf{NameAndTeachVector(char positionMethod)}\\}
Funktionen starter med at sætte et vektornavn, hvorefter det inkrementeres således, at de
forskellige vektorer der oprettes, får forskellige navne. 
Vektoren bliver derefter oprettet med navnet samt to andre parameter som er konstante og definerede
til en given værdi. Funktionen returnere true hvis det blev oprettet, samt false hvis det 
ikke lykkedes. Parameteren positionMethod bliver valideret om det er et 'R', dette betyder
at vektor koordinaterne får en relativ placering. 
Alt andet end 'R' sætter det til absolut placering. 
Herefter bliver teach kaldt, som indsætter koordinaterne i den givne vektor og returnere
true, hvis det sker uden fejl.\\\\
\textit{\textbf{MoveRobot(Int32 x, Int32 y, Int32 z, Int32 p, Int32 r, char positionMethod)}}\\
Herunder ses et lille sekvensdiagram over forløbet i funktionen:
\begin{figure}[H]%[hbtp]
\centering
\includegraphics[scale=0.4]{Diagrammer/dSSD/RobotProgramFunctions/JPEGFiler/MoveRobot.jpg}
\caption{Sekvensdiagram: MoveRobot}
\end{figure}
Funktionen starter med at bruge de 5 første parameter til funktionen DefineVektorCoordinates().
Denne funktion tager de 5 parametere som den indsætter i et array, hvori hver parameter bliver
ganget med 1000, således, at det passer med robottens koordinatsæt. Derefter bliver 
NameAndTeachVector kaldt med den sidste parameter. 
MoveLinear bliver herefter kaldt, og det bliver valideret, om det lykkedes at kalde den med 
vektornavnet samt, at den er rykket til de koordinater, der er medgivet.
I tilfælde af at det lykkes, startes der med at blive sat en bool, som angiver at robotten er 
i bevægelse. Dette bliver derefter logget til databasen, hvis det er det rigtige
program og logget til en fil, hvis det er simulering. 
En while løkke ser herefter på boolen, der blev sat tidligere, om den har ændret sig til
false, dette sker gennem en callbackfunktion som ser på om robotten er i bevægelse. 
Når den ikke længere er i bevægelse bliver den sat til false og funktionen slutter.\\
\subsubsection*{Sorteringsalgoritme}
I sorteringsalgoritmen for at sortere en klods, bliver der lavet mange kald til MoveRobot. MoveRobot har flere parametre, hvor en af dem angiver om det er relativ eller absolut placering. For at gøre algoritmen nemmere at ændre i, er der lavet hovedpunkter med absolut placering. Der er lavet et absolut punkt til startpositionen, som er lige over sensoren for transportbåndet og et andet som er lige over vægten. Endvidere er der lavet forskellige absolutte punkter til de forskellige rum i kassen, hvor klodserne bliver sorteret. 
Ud fra disse absolutte punkter er der så lavet forskellige sekvenser, som er lavet med relative punkter, som tager udgangspunkt i det sidst satte koordinatsæt og flytter sig derefter.  Det har medført, at det har været nemmere at lave justeringer til at lave den givne sekvens helt præcis. 
Der er lavet funktionalitet, så det er muligt at flytte transportbåndet, som er dybere beskrevet i \textit{afsnittet: 8.2.3 Komponent 3: Bestem placering af Transportbånd} , og dette har gjort det nemmere med relative placeringer, da der kun skulle ændres på x og y koordinaterne i det hovedpunkt, som var vores startposition over transportbåndet. Funtkionernes sekvensdiagrammer kan findes i bilag \\\\
\textit{\textbf{SortingBrick()}}\\
Som det første i denne funktion kaldes WatchMotion (se begrundelse i ovenstående \textit{OpenCloseGripper(bool openClose)}). Herefter åbnes gripperen og flyttes til en startposition over sensoren via MoveRobot (se \textit{MoveRobot(Int32 x, Int32 y, Int32 z, Int32 p, Int32 r, char positionMethod)}) i det overstående for nærmere information). Herfra køres en sekvens af relationelle MoveRobot kald, der søger for, at gripperen får greb om alle siderne på en klods, samt at den kommer over på vægten (se \textit{Absolut eller relativ placering} i det ovenstående, for beskrivelse af hvordan bevægelsessekvensen er opbygget). I denne sekvens, måles de forskellige sider, og gemmes i den nævnte Brick klasse. Til sidst i sekvensen flyttes robotarmen tilbage til startpositionen, med klodsen i gripperen. hereftere bliver en funktionen MoveBrickToBox kaldt, der søger for at ligge klodsen i det rigtige rum  (se \textit{MoveBrickToBox()} i det nedstående).
\\\\
\textit{\textbf{MoveBrickToBox()}}\\
Det første der sker i denne funktion er, at materialetypen og materialenavnet findes, gennem kaldet til GetMaterialType(). Denne funktion diskuteres yderligere i nedenstående afsnit. Hvis det er muligt at finde frem til materialetypen for den givne klods, hentes samtlige længder for alle klodser der er persisteret i systemet, med den fundne materialetype. Dette skal bruges til at finde ud af, hvor langt klodsen skal skubbes frem i boksen. Dette sker gennem kaldet til GetTotalBrickLength(). Denne funktion opretter en ny besked, med parametre der indikerer, at det er længden for klodser med den givne materialetype der skal hentes. Herefter sendes beskeden ind i beskedkøen, og tråden venter på at den får svar ved at tage en semafor. Imens holder notifiertråden øje med, om der er kommet nogle nye beskeder i beskedkøen. Når den så modtager beskeden, behandler den beskeden\footnote{Se afsnit 8.2.7: implementerings view: observer pattern, for håndtering af beskeder}
, og da dette er en "Select" besked, henter den de ønskede data, og ligger dem i ReceivedItemsList. Samtidig frigiver den en semafor, hvilket får den anden tråd til at køre videre. Tråden, som kalder MoveBrickToBox, ligger så indholdet fra ReceivedItemsList ind i en property, som bruges senere i MoveBrickToBox funktionen. Herefter kaldes InsertPositionToDataBase, som indsætter en ny position i databasen, og denne findes ud fra materialetypen, og antallet af eksisterende klodser i databasen med den givne materialetype. Dette foregår vha. en "Insert" besked, som ligeledes behandles af notifier-tråden. Herefter hentes et ID, svarende til den nyoprettede position i boksen. Dette ID skal bruges, når klodsen indsættes i databasen, hvilket sker i næste funktion: InsertBrickIntoDataBase. Denne opretter en "Insert" besked, som skal indsætte de nyligt fundne data for en klods, samtidig med at der medgives to ID'er, så klodsen i databasen har to fremmednøgler; en der peger på en positionering og en der peger densitet. Når alle data er persisteret på databasen, bliver klodsen sorteret alt efter materialeafsnit: \textit{jævnfør afsnit: MoveToFirstBox i 8.2.5: i dette afsnit.}
\\\\
\textbf{GetMaterialType} \\
Denne funktion hjælper systemet med at finde en materialetype i databasen, som stemmer overens med den udregnede densitet. Dette kan ses på nedenstående sekvensdiagram. 

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{Diagrammer/dSSD/RobotProgramFunctions/JPEGFiler/GetMaterialType.jpg}
\caption{Sekvensdiagram over GetMaterialType()}
\end{figure}

Først oprettes en "SelectBetween" besked. Grunden til at der bruges en "SelectBetween" og ikke en "Select" skyldes, at der altid vil være et udsving, når densiteten udregnes, og derfor er der nødt til at være en fejlmargin, når materialetypen skal findes på databasen. Derfor medsendes der to parametre i beskeden, den første er densiteten minus en fejlmargin og den anden er densiteten plus en fejlmargin. Fejlmarginen er den største mulige margin, der sørger for, at to standardmaterialetyper ikke overlapper. I koden medgives selvfølgelig også, hvilken tabel der søges i, og hvilke værdier der ønskes fundet osv. Herefter ligges beskeden ind i beskedkøen. Tråden venter så på, at beskeden bliver behandlet af notifiertråden, som ligger de ønskede værdier fra databasen ind i ReceivedItemsList i observeren, selvfølgelig kun hvis dataene kan hentes på databasen. Hvis de ikke kan findes, vil der blive kastet en exception, når det første indhold i ReceivedItemsList bliver tilgået. Denne exception bliver så "fanget" og false bliver returneret. Hvis materialetypen derimod er blevet fundet, gemmes værdierne fra ReceivedItemsList i en property, hvorefter ReceivedItemsList bliver tømt, så den er klar til at indeholde nye data. Når materialetypen er fundet, skal navnet på materialetypen hentes. Hvis det blot havde været en "Select" statement, havde det være muligt at hente begge værdier samtidig, men der er ikke blevet implementeret en "SelectBetween" sætning i databasefacaden, som kan hente flere kolonner. Navnet hentes gennem en "Select" besked, som søger på materialetypen, der netop er blevet fundet. Beskeden ligges ligeledes ind i en beskedkø, og en semafor bliver taget, der søger for at tråden venter på, at beskeden bliver behandlet af notifiertråden. Når den er blevet behandlet, bliver indholdet af ReceivedItemsList igen gemt i en property. Denne property bliver logget samtidig med, at GUI'en\footnote{Vinduet hvor selve sorteringsvinduet bliver vist: RunWindow} anvender denne property til at udskrive materialetypen på skærmen.
\\\\
\textit{MoveToFirstBox() En af funktionerne fra switch-casen}\\
Funktionen starter med et aktuelt punkt ved boksens bund, med klodsen midt over kanten. Fra dette punkt flyttet klodsen på plads med relative koordinater. Ideen (som også er blevet udført via det relative positioner) er at flytte klodsen ind over kanten, ved at dividere klodsens egen længde med to, og bruge denne længde så klodsen netop går indenfor kanten. Her slippes klodsen hvorefter gripper går om bagved klodsen. herefter skubbes klodsen på plads, så den ligger ved siden af de andre klodser. Dette gøres via boksens længde, minus klodsernes længde\footnote{Den samlede længde af klodser med den givne materialetype, som er fundet i GetTotalBrickLength()}, klodsens egen længde, samt gripperens bredde. For at den bliver skubbet lige på plads, har det også være nødvendigt at udregne en rollfaktor. Denne søger for at gripperen ikke bevæger sig skævt. Når man laver en vektor, skal der medgives en roll-koordinat, der fortæller om gripperen skal rotere. Denne faktor bliver ganget på dette koordinat.\\r 
Faktoren er udregnet på følgende måde\\
\begin{align}
\dfrac{r2-r1}{\sqrt{(x2-x1)+(y2-y1)}}
\end{align}
x1 og x2 svarer til koordinatet i den ene ende af boksen og den anden ende af boksen. Ligeledes forholder det sig med r og y koordinaterne. Det har altså været nødvendigt, at finde koordinaterne til denne udregning.  
\end{document}