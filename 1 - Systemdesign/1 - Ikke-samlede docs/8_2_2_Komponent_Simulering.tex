\documentclass[Main.tex]{subfiles} 
\begin{document}

\subsubsection{Komponent 2: Simulering}
Denne komponent har til formål at simulere robotten.
Der er nogle gode grunde til at simulere robotten udover den, at selve produktoplægget kræver en simulering:
\begin{itemize}
\item Først og fremmest skal man være opmærksom på, at der kun er en robot til rådighed. Dermed er det kun en begrænset tid man har adgang til robotten, hvormed det kan blive svært at teste ens programmer.
\item Derudover tager det minimum to minutter at home robotten, hvilket ofte vil være en nødvendighed for at teste sit program. Dermed vil den kostbare tid man har ved robotten, blive formindsket endnu mere.
\end{itemize}
Med disse ulemper taget i betragtning, er det klart, at en simulering vil være en stor fordel.\\\\
\textbf{Design:}\\
Simulatoren består af forskellige simulerings-klasser. Disse oprettes og bruges via constructor-injection på programmet. Der er blevet taget udgangspunkt i, at man skal kunne simulere ens program uden nogen kontakt til robot eller database. Dermed har det være nødvendigt at lave følgende klasser:
\begin{itemize}
\item RoboSimulationCalls (implementerer IRoboCalls. Heri ligger samtlige funktioner der bruges til robotten)
\item DataBaseSimulation (implementerer IDatabaseFacade)
\item DatabaseObserverSimulering (implementerer IObserver)
\item FakeWeight (implementerer IWeight)
\item FakeRobotEvent (implementerer IRobotEvent)
\end{itemize}
Forskellen på simulatorerne og fake klasserne, er at simulatorerne logger nogle strenge med information over hvad der er sket, mens fake klasserne sætter nogle variable, der søger for at programmet kan køre uden robotten. Dermed kan man køre det rigtige program, i samspil med robotten, eller nøjagtig det samme program som en simulering. Dette sikres som nævnt via constructor-injection.\\
En anden vigtig del af simulatoren er loggen. Ud fra log interfacet er der implementeret tre forskellige logningsmetoder, hvor simuleringen bruger to af dem. Simuleringen logger til et vindue, samt til en fil der ligger i en mappen Simuleringslogs i rodmappen (RobotProjekt mappen)\\
Diagrammerne i afsnit \textit{5.3.7 Use Case 5} kan give et overblik over simulatoren.\\
\textbf{RoboSimulationCalls klassen:}\\
Herunder ses et kodeudsnit fra en af funktionerne i RoboSimulationCalls:
\begin{lstlisting}[caption=Funktionen Initialization(...)]
public bool Initialization(short sMode, short sSystemType)
{
    string sModeS;
    string sSystemTypeS;
    switch (sMode)
    {
        case 0:
            sModeS = "INIT_MODE_DEFAULT selects last used mode (from ini file).";
            break;
        case 1:
            sModeS = "INIT_MODE_ONLINE force online mode.";
            break;
        case 2:
            sModeS = "INIT_MODE_SIMULAT selects simulation mode.";
            break;
        default:
            sModeS = "Unknown INIT_MODE.";
            break;
    }
    switch (sSystemType)
    {
        case 0:
            sSystemTypeS = "DEFAULT_SYSTEM_TYPE let the libary detect the robot type.";
            break;
        case 41:
            sSystemTypeS = "ER4USB_SYSTEM_TYPE define robot type as ER-4 Scorbot with USB connection.";
            break;
        default:
            sSystemTypeS = "Unknown SYSTEM_TYPE.";
            break;
    }

    logWindow.LogThis(loggingLevels.INFO, "Initialization: " + retVal, false);
    logWindow.LogThis(loggingLevels.INFO, "Initialization MODE: " + sModeS + " ## " + sSystemTypeS, true);

    logFile.LogThis(loggingLevels.INFO, "Initialization: " + retVal, false);
    logFile.LogThis(loggingLevels.INFO, "Initialization MODE: " + sModeS + " ## " + sSystemTypeS, true);
    logFile.LogThis(loggingLevels.INFO, "newline", false);

    initRuned = true;
    return retVal;
}
\end{lstlisting}
Ovenstående eksempel følger den måde, hvorpå simulatoren er opbygget. Den tager parametre, som svarer til et mode eller lignende, og genererer et tekststreng ud fra det. Hvilket mode det svarer til er fundet i USBC-documentationen. Tekststrengen bliver derefter logget. Derudover er funktionerne opbygget således at de alle returnerer en bool. Denne returværdi er i simuleringssammenhæng en bool, som man selv kan sætte værdien på.\\
Som det ses i eksemplet sættes et private variabel 'initRuned'. Denne fungerer som validering. Hvis andre funktioner kaldes før denne er sat, får brugeren af vide, at robotten ikke er initialiseret. Udover denne sættes en variabel i Control og Home funktionen også, da disse er essentielle for at mange af robotfunktionerne kan kaldes.\\\\
\textbf{DatabaseObserverSimulering klassen:}\\
Denne klasse er som sådan ikke en simulering. Den har samme funktionalitet som den rigtige version, men undlader funktionalitet til at håndtere en tabt forbindelse til databasen.\\\\
\textbf{DataBaseSimulation klassen:}\\
Denne håndterer kaldene fra DatabaseObserverSimulering. Den er opbygget efter samme princip som hovedsimulatoren "RoboSimulationCalls", hvor en streng, opbygget ved hjælp af input, logger til konsol og fil.

\end{document}