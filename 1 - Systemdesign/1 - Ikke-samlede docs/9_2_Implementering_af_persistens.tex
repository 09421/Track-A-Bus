 \documentclass[Main.tex]{subfiles} 
\begin{document}

\subsection{Implementering af persistens}
Datapersistering og datahentning er vigtig komponent i dette system. Implementering af persistens vil derfor blive beskrevet meget nøje, og herunder delt op i tre dele; Implementering af persistens i mobilapplikation, Implementering af persistens i simulator og Implementering af persistens i online værktøjet. Hver del vil ikke have en beskrivelse af den fulde implementering, men blot repræsenteret af væsentlige dele. For fuld implementering af persistens henvises der til bilags CDen, i den respektive komponent under mappen Kode.

\subsubsection{Implementering af persistens i mobilapplikationen}
Persistering i denne komponent falder i to underpunkter. Dette er fordi, denne komponent er den eneste, som har kontakt til to databaser; Den distribuerede MySQL database samt den lokale SQLite database. Disse to vil blive beskrevet i seperate afsnit. \\\\
\noindent
\textbf{Tilgang til MySQL databasen}\\
Mobilapplikationen har aldrig direkte tilgang til den distribuerede database. Tilgangen sker i afsnittet \textit{8.2.2: Komponent 2: Mobil service}.\\
Applikation kommunikerer med databasen igennem en service, og altid kun som en læsning. Dette gør det muligt at tilgå databasen fra flere enheder, da en database læsning er trådsikker. Grunden til at der bliver gjort brug af en service er, at database tilgangen skal kunne gemmes væk fra brugeren, således en person ikke kan få fuld tilgang til databasen igennem sin mobil. Desuden vil mobil applikationen nemt kunne skiftes ud, uden at skulle tænke på tilgangen til databasen.\\
Selve kommunikationen med servicen sker igennem en SoapProvider. SOAP bruges som en transportmetode til XML beskeder. Når mobilen tilgår servicen opretter den en SOAP-envelope, der indeholder information om, hvilken metoden der skal kaldes, under hvilket namespace metoden ligger, samt eventuelle parametre metoden. På kodeudsnit \ref{lst:SoapProvider} kan en generisk oprettelse og transmitering af en SoapEnvelope ses. 
\begin{lstlisting}[caption=Generisk SoapEnvelope., label={lst:SoapProvider},language=Java]
SoapObject request = new SoapObject(NAMESPACE, METHOD_NAME);
request.addProperty(PARAMETER_NAME, PARAMETER_VALUE);
SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);
envelope.dotNet = true;
envelope.setOutputSoapObject(request);
HttpTransportSE androidHttpTransport = new HttpTransportSE(URL_OF_SERVICE);
androidHttpTransport.call(NAMESPACE+METHOD_NAME, envelope);
SoapObject response = (SoapObject)envelope.getResponse(); 
\end{lstlisting}
Requestet oprettes som et SoapObject, hvor metodenavnet, samt det namespace metoden ligger i, gives med. Disse to parametre er strings. Til metodekaldet kan der tilføjes parametre ved "addProperty" metode, som tager imod et parameter navn og en parameter værdi, begge to strings. Envelopen bliver oprettet og et versionsnummer bliver givet med, der definerer hvilken version af protokollen der skal tages i brug. I dette system bliver der udelukkende gjort brug af version 1.1. dotNet flaget er sat til true, da servicen er skabt i ASP.NET. Request-objektet sættes i envelopen, og kommunikerer med servicen over HTTP. Efter den relevante metode er færdigjort på servicen bliver returværdien sat i envelopen, og et SoapObject indeholdende de returnerede værdier kan hentes ved et kald til "getResponse" metoden på envelopen.\\
Et SoapObject er reelt set et XML-træ, som kan itereres igennem. Et eksempel på et sådan XML-struktur kan ses i afsnitet \textit{8.2.2: Komponent 2: Mobil service}\\ Et fuldt eksempel på et kald til servicen kan ses på kodeudsnit \ref{lst:GetBusPos}. Denne funktion bruges til at hente samtlige busser med et givent busnummer, og returnere dem som en ArrayList.
\begin{lstlisting} [caption=GetBusPos. Returnerer alle bussers position på en given rute., label={lst:GetBusPos},language=Java]

final String NAMESPACE = "http://TrackABus.dk/Webservice/";
final String URL = "http://trackabus.dk/AndroidToMySQLWebService.asmx"; 
...
public ArrayList<LatLng> GetBusPos(String BusNumber)
{	  
	  ArrayList<LatLng> BusPoint = new ArrayList<LatLng>();
	  try
	  {
		  	SoapObject request = new SoapObject(NAMESPACE, "GetbusPos");
		  	request.addProperty("busNumber", BusNumber);
		  	SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);
		  	envelope.dotNet = true;
		  	envelope.setOutputSoapObject(request);
			HttpTransportSE androidHttpTransport = new HttpTransportSE(URL);
			androidHttpTransport.call(NAMESPACE+"GetbusPos", envelope);
			SoapObject response = (SoapObject)envelope.getResponse();
			
			for(int i = 0; i<response.getPropertyCount(); i++)
			{
				double a = Double.parseDouble(((SoapObject)response.getProperty(i)).getProperty(0).toString().replace(",", "."));
				double b = Double.parseDouble(((SoapObject)response.getProperty(i)).getProperty(1).toString().replace(",", "."));
				BusPoint.add(new LatLng(a, b));
			}
	  }
	  catch(Exception e)
	  {
		  return null;
	  }
	  return BusPoint;
}
\end{lstlisting}
\noindent
Metoden på servicen returnerer en liste, indeholdende typen "Point", som er en custom datatype lavet i servicen. Denne har to attributer, Latitude og Longitude, som begge er strings. "getPropertyCount" funktionen returner længden af denne liste, og bruges til at iterere igennem den. \\
Det første kald af "getProperty" på responset, returnerer "Point" datatypen. Denne property castes til et nyt SoapObjekt, hvor "getPropety" kaldes igen. Rækkefølgen af propeties i et SoapObject, defineres af rækkefølgen de bliver oprettet i, i datatypen. I "Point" kommer latitude først og longitude kommer bagefter. "GetProperty(0)" på et "Point" SoapObjekt vil derfor returnere Latitude og "GetProperty(1)" vil returnere Longitude. Begge bliver castet til en string, og floatingpoint sættes til et dot frem for et komma. Dette gøres da ASP.NET tager et floatingpoint som værende komma.\\ 
Da applikationen er lavet til Android bruges biblioteket ksoap2\footnote{For mere information, se \url{http://ksoap2.sourceforge.net/}}, som er specifik for Android. I dette bibliotek ligger alle funktioner, der er nødvendige for at bruge af SOAP.

\noindent
\textbf{Tilgang til SQLite databasen}\\
Når en busrute favoriseres gemmes alt data om denne i en lokal SQLite database. Dette gøres for at spare dataforbrug, hvis en rute tages i brug ofte. Samtidig muligøres det også, at brugeren kan indlæse en rute med stoppestedder, uden at have forbindelse til internettet. Hvis kortet samtidig er cachet (Google Maps cacher indlæste kort), kan kortet også indlæses og indtegnes.\\
Der er gjort brug af en ContentProvider i denne sammenhæng, som abstraherer data-access laget, så flere applikationer kan tilgå databasen, med den samme protokol, hvis det skulle være nødvendigt.\\ En ContentProvider tilgås igennem et kald til "getContentResolver", hvorefter der kan kaldes til de implementerede CRUD-operationer. En ContentProvider skal defineres i projektets AndroidManifest, før den kan tilgås. Dette gøres ved at give den et navn, samt en autoritet, som dette tilfælde, er den samme værdi som navnet. Hvis ContentProvideren bruges i en anden applikationen, skal den have en autoritet tilsvarende den, den er blevet oprettet med.\\
Da ContentProvideren blot er et transportlag mellem brugeren og databasen, er det nødvendigt for den, at kende den egentlige database. Dette er gjort ved at lave en inner class til provideren, som extender SQLiteOpenHelper. Denne klasse indeholder create proceduren, samt muligheden for at kunne tilgå både en læsbar og skrivbar version af databasen. Create proceduren bliver kørt, hvis databasen med det valgte navn ikke eksisterer i forvejen, og bruges til at oprette databasen og tabellerne deri. En SQLite database gør, som default, ikke brug af foreign key constraints. Det er derfor blevet implementeret sådan, at foreign key contraints aktiveres hver gang databasen åbnes.\\
Hver CRUD-operation modtager et URI, der skal være en kombination af en identifieren "content://", en autoritet (ContentProviderens placering) samt evt. en tabel og en underoperation.  Hvis en given CRUD-operation på ContentProvider siden er lavet, sådan at der altid gøre det samme (f.eks. en query der altid returner alt data i den samme tabel), vil identifieren og autoriteten være nok, til at kunne tilgå denne operation. Hvis tilgangen derimod skal være specifik for en given tabel, og evt. underoperation kan en UriMatcher tages i brug. Denne kobler et URI med en given værdi, hvorefter der i operationen kan laves en switch/case der matcher det medsendte URI, og vælger en operation ud fra dette. På \ref{lst:URIexample} ses et eksempel på, hvordan dette er implementeret i systemet. Det skal noteres at dette ikke er komplet implementering, men blot et udsnit. Kommentarer vises ved "!!"
\begin{lstlisting}[caption=GetBusPos. ContentProvider implementering., label={lst:URIexample},language=Java]
!!ContentProvider class!!
public static final String AUTHORITY = "dk.TrackABus.DataProviders.UserPrefProvider";
public static String BUSSTOP_TABLE = "BusStop";
private static final int BUSSTOP_CONTEXT = 1;
private static final int BUSSTOP_NUM_CONTEXT = 2;
...
static {
	uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
	uriMatcher.addURI(AUTHORITY, BUSSTOP_TABLE, BUSSTOP_CONTEXT);
	uriMatcher.addURI(AUTHORITY, BUSSTOP_TABLE+"/#", BUSSTOP_NUM_CONTEXT);
}
...
public Cursor query(Uri uri, String[] projection, String selection,
		String[] selectionArgs, String sortOrder)
String Query;
SQLiteDatabase db = dbHelper.getReadableDatabase()
switch(uriMatcher.match(uri))
{
	case BUSSTOP_CONTEXT:
		routeID = selection;
		query = !!Query to get all busstops and their position on a route with id being RouteID!!
		returningCursor =  db.rawQuery(query,null);	
		break;
	case BUSSTOP_NUM_CONTEXT:
		stopID = uri.getLastPathSegment();
		query = !!Query to get a single bustop with id being stopID!!
		returningCursor =  db.rawQuery(query,null);	
	default
		return null;
}
return returningCursor;

...
!!BusStop model class!!
public static final Uri CONTENT_URI = Uri.parse("content://"
			+ UserPrefProvider.AUTHORITY + "/BusStop");
			
...
!!Hentningen af stoppesteder!!
getContentResolver().query(UserPrefBusStop.CONTENT_URI, null, RouteID, null, null);
String StopID = !!Some ID!!
String specifikStop = UserPrefBusStop.CONTENT_URI.toString() + "/"+ StopID;
getContentResolver().query(Uri.parse(specifikStop),null,null,null,null);

\end{lstlisting}
Den første del af kodeeksemplet viser oprettelsen af UriMatcheren. Hvis UriMatcheren kender det ID den bliver givet ved i dennes "match" funktion, vil den returne en værdi, der svarer til den, den er blevet givet ved oprettelse. Herefter ses et udsnit af "query" metoden. Hvis URI'et kun indeholder BusStop udover autoriteten, vælges BUSSTOP\_CONTEXT, og der hentes alle stoppesteder, som er relevant for den rute der sættes i selection parameteren. Hvis tabellen efterfølges af et nummer i URI'et, vælges BUSSTOP\_NUM \_CONTEXT, og der hentes kun det stoppested som har det ID sat i URI'et.\\
Til samtlige tabeller i SQLite databasen er der lavet en model klasse. Disse klasser indeholder kun statiske variabler som definerer den givne tabels kolonner samt den URI, ContentProvideren skal have med, for at kunne tilgå den tabel, modellen definerer.\\ I sidste del af kodeafsnittet kan det ses, hvordan ContentProvideren tilgås. Det første kald tilgår query funktionen under BUSSTOP\_CONTEXT, og henter alle stoppesteder ud for ruten hvor ID'et er "RouteID" . Det andet kald tilgår også query funktionen men under BUSSTOP\_NUM\_CONTEXT, og henter stoppestedet ud hvor ID'et er "StopID". \\
\noindent
\subsubsection{Implementering af persistens i simulator}
Simulatoren implementerer persistens i form af at hente ruter, opdatere hvilken vej en bus kører, samt udregne og persistere ny GPS position for en bus. Samtlige busser kører i deres egen tråd i simulatoren, derfor er det vigtigt at håndtere trådsikkerhed når databasen skal tilgås. DatabaseAccess klassen tager sig af selve databasen tilgangen, og indeholder to funktioner; En til at skrive til databasen, samt en til at læse. Begge funktioner er statiske, og indeholder en binær semafor, således kun en tråd af gangen kan tilgå databasen. Hvis en tråd allerede er igang med en datahentning eller -skrivning, vil den anden tråd tvinges til at vente, til processen er færdig. Begge funktioner modtager en string, som er den kommando der skal udføres på database. Funktionen der læser fra databasen tager yderligere en liste af strings, som indeholder de kolonner der skal læses fra. Efter fuldent tilgang returneres en liste af strings, med de værdier der er blevet hentet. \\Databasen tilgangen bliver håndteret med i librariet MySQL.Data.\footnote{For mere information, se \url{http://dev.mysql.com/doc/refman/5.6/en/connector-net.html}} Da simulatoren er lavet i Visual Studio 2012, og er en WPF-applikation, er der blot gjort brug af NuGet\footnote{Et integret værktøj i Visual Studio 2012, til at hente og tilføje biblioteker} til at hente og tilføje dette bibliotek til programmet. Forbindelsesopsætningen ligger i App.config filen, og hentes ud når der skal bruges en ny forbindelse. På kodeudsnit \ref{lst:SimuDatabaseAcces} ses funktionen der læser fra databasen, samt hvordan den tilgås. Kun denne vil vises, da det er den mest interresante. Fuld kode kan findes på bilags CDen under Kode/Simulator. 
\begin{lstlisting}[caption=Simulator. Select statement., label={lst:SimuDatabaseAcces},language=Java]
public static bool SelectWait = false;
public static List<string> Query(string rawQueryText,List<string> columns)
{
	while(SelectWait)
	{
		Thread.Sleep(10);
	}
	SelectWait = true;
    using(MySqlConnection conn = new MySqlConnection(ConfigurationManager.ConnectionStrings["TrackABusConn"].ToString()))
	{
		using(MySqlCommand cmd = conn.CreateCommand())
		{
			try
			{
				List<string> returnList = new List<string>();
				cmd.CommandText = rawQueryText;
				conn.Open();
				MySqlDataReader reader = cmd.ExecuteReader();
				while (reader.Read())
				{
					foreach (string c in columns)
					{
						returnList.Add(reader[c].ToString());
					}
				}
				reader.Close();
				conn.Close();
				SelectWait = false;
				return returnList;
			}
			catch(Exception e)
			{
				SelectWait = false;
				return null;
			}
		}
	} 
}
...
String query = "Select BusRoute.ID from BusRoute";
List<string> queryColumns = new List<string>(){"ID"};
List<string> returnVal= DatabaseAcces.Query(query, queryColumns);
\end{lstlisting}
Der ventes i starten af funktionen på, at semaforen frigives. Hvis tråden skal tilgå databasen og en anden tråd allerede er igang, ventes der på, at den låsende tråd gør processen færdig og sætter SelectWait til false.\\
Når forbindelsen oprettes, gives den en configurations string. Denne string indeholder database navn, server, brugernavn og password, som er alt hvad forbindelsen skal bruge, for at tilgå databasen. Af denne forbindelse laves der en kommando, som indeholder alt den information som skal eksekveres på forbindelsen.  Ved kaldet til "ExecuteReader", udføres kommandoen og en reader returneres med de rækker der kunne hentes udfra den givne query. I skrivnings funktionen ville "ExecuteNonQuery", blive kaldt i stedet, da der, i dette tilfælde, ikke skal returneres noget data. Readeren repræsenterer en række i databasen, og når "Read" funktionen kaldes på den, tilgås den næste række. Hvis "Read" returner false, er der ikke flere rækker at læse. Når data skal hentes ud fra readeren, kan der enten vælges at bruge index (kolonne nummeret i rækken), eller kolonnenavn. I dette tilfælde gives samtlige kolonner med som en parameter, og derfor læses der på navn. Til sidst frigøres semaforen og læst data returneres.\\
I slutningen af kodeudsnittet kan det ses, hvordan denne funktion tilgås. Først laves der en query, som i dette tilfælde henter samtlige busrute IDer. Herefter oprettes der en liste af de kolonner der skal hentes, hvorefter Query funktionen kaldes med begge værdier.

\subsubsection{Implementering af persistens i online værktøjet}
Online værktøjet består af to dele; Mobil servicen og hjemmesiden. Begge dele er lavet i ASP.NET, og derfor vil database tilgangs proceduren være ens med simulatoren. Servicen står får at lade mobil applikationen tilgå data på MySQL databasen, hvilket også betyder, at funktionerne kun læser data. Ved et kald til servicen vil læst data pakkes ved hjælp af SOAP, som er beskrevet i \textit{9.2.1: Implementering af persistens i mobil applikationen}.\\ Servicen står i midlertid også for at kalde tidsudregnings proceduren på databasen, hvilket er et anderledes kald, end en læsning. På kodeudsnit \ref{lst:kaldTilTidsUdregning} ses det, hvordan servicen tilgår denne procedure. Det skal noteres at det ikke er den fulde funktion der vises, men blot et udsnit, og derfor kun viser de vigtigste dele. Herved vises der ikke hvordan forbindelsen og kommandoen laves, da oprettelsen er ens med simulatoren.
\begin{lstlisting}[caption=Service. Udsnit af kald til tidsudregnings procedure, label={lst:kaldTilTidsUdregning},language=Java]
...
cmd.CommandText = "CalcBusToStopTime";
cmd.CommandType = System.Data.CommandType.StoredProcedure;
...
cmd.Parameters.Add("?stopName", MySqlDbType.VarChar);
cmd.Parameters["?stopName"].Value = StopName;
cmd.Parameters["?stopName"].Direction = System.Data.ParameterDirection.Input
...
cmd.Parameters.Add(new MySqlParameter("?TimeToStopSecAsc", MySqlDbType.Int32));                     
cmd.Parameters["?TimeToStopSecAsc"].Direction = System.Data.ParameterDirection.Output;
...
cmd.ExecuteNonQuery();
...
string TimeToStopAsc = cmd.Parameters["?TimeToStopSecAsc"].Value.ToString();
string EndStopAsc = cmd.Parameters["?EndBusStopAsc"].Value.ToString();
\end{lstlisting}
I kodeudsnittet kan det ses, at der bliver tilføjet flere værdier til kommandoen i forhold til kodeudsnit \ref{lst:SimuDatabaseAcces}, hvor der kun blev tilføjet en enkelt. Først og fremmest bliver kommandotypen sat som værende en Stored Procedure. Herefter kan det ses hvordan både en input og en output parameter bliver sat i kommandoen. Parametrene bliver givet et navn, samt en datatype, hvorefter de gives en værdi hvis de er input parametre. Herefter gives parametrene en retning; Input hvis de er værdier der skal læses i proceduren og output hvis de skal skrives til. Efter proceduren er kørt, vil output parameterne nu kunne læses, med de værdier der er blevet udregnet. I dette tilfæde er der kun vist to parametre, men antallet og deres navne og retning, skal passe overens med den procedure der er lavet på database siden. De oprettede Stored Procedures er trådsikre, og dette beskrives i afsnittet \textit{9.1.2: Stored Procedures}.\\

Da databasetilgangen på hjemmesiden kun er flertrådet når der læses, er systemet trådsikkert. Når der læses vil det altid ske fra den med server tråden. Databasen tilgås ligesom servicen og simulatoren ved hjælp af MySql.Data bibilioteket\footnote{For mere information, se \url{http://dev.mysql.com/doc/refman/5.6/en/connector-net.html}}, og tilgås kun i form af simple CRUD-operationer. Der vil derfor ikke vises et kodeeksempel, da dette anses som værende beskrevet i tidligere afsnit. Samtlige funktioner er samlet i DBConnection klassen, som agerer som data tilgangs laget. Det vil sige, at alle database aktioner tilgås igennem denne klasse.
\end{document}