\documentclass[Main.tex]{subfiles} 
\begin{document}
\subsubsection{Komponent 1: Mobil applikation}
Denne komponent har til formå at formidle alt bus information til brugerne. Den gør det muligt for brugeren at se busruter med stoppesteder indtegnet på et kort samt positionen for de busser der køre på ruten. Herudover vil det være muligt at se hvor lang tid der er til, at den næsten bus ankommer ved et valgt busstoppested. På figur \ref{fig:AppKlasseDiagram} kan de forskellige klasser ses, samt hvilke lag de ligger i og hvordan de interagerer. Model klasser vises ikke som interageringer.
\\
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{./Diagrammer/Klassediagrammer/App_klasseDia.jpg}
	\caption{Klassediagram for mobil applikationen}
	\label{fig:AppKlasseDiagram}
\end{figure}
\newpage
\noindent
På figur \ref{fig:AppKlasseDiagramModel} ses de forskellige model klasser, der hovedsageligt består af custom datatyper.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{./Diagrammer/Klassediagrammer/App_klasseDia_models.jpg}
	\caption{Klassediagram for model klasser i mobil applikationen}
	\label{fig:AppKlasseDiagramModel}
\end{figure}

\noindent
\textbf{Design:}\\
Applikationen er blevet udviklet til android mobiltelefoner som kører med OS version 4.3 Jelly Bean og op til 4.4 KitKat. Dertil er der blevet udviklet imod android API level 18 og 19.
\\
Mobil applikationen er udviklet med fokus på, at der skulle ske så lidt arbejde på telefonen som muligt. Alle tunge udregninger og processeringer sker på en webservice, \textit{Se afsnit 8.2.2 Komponent 2: Mobile service}
\\
For at kunne vise busruter, stoppesteder, busser og tid til ankomst, skal dette hentes fra en databasen. Til dette formål er der blevet lavet to klasser, TrackABusProvider og SoapProvider. TrackABusProvideren er udviklet som en BoundService, som både BuslistMenuActivity og BusMapActivity bruger. For at binde til TrackABusProvideren, bliver "startService" kaldt, som starter servicen, hvis den ikke allerede kører. Herefter vil funktionen "bindService" blive kaldt, som i dette tilfælde binder BuslistMenuActivity til TrackABusProvideren.
\begin{lstlisting}[caption=Binding til TrackABusProvider, language=JAVA]
if(ConnectivityChecker.hasInternet){
	Intent intent = new Intent(BuslistMenuActivity.this, TrackABusProvider.class);
	startService(intent);
	bindService(intent, Connection, Context.BIND_AUTO_CREATE);	
	}
\end{lstlisting}
Denne binding vil ske asynkront, og det er derfor ikke muligt at vide, hvornår den er færdig. Til dette formål bruges en ServiceConnection. Denne har en callback function, "onServiceConnected", der vil blive kaldt så snart der er blevet bundet til servicen. For at sikre at de funktioner, som kræver en bundet service, først bliver kaldt når dette er opfyldt, bliver kaldt i onServiceConnected. "getService" vil initialisere en instans af den service der er bliver bundet til, og herfra vil det være muligt at kalde de forskellige service funktioner, der er implementeret i TrackABusProvider klassen.
\begin{lstlisting}[caption=ServiceConnection i BuslistMenuActivity, language=JAVA]
private ServiceConnection Connection = new ServiceConnection(){			
	@Override
	public void onServiceConnected(ComponentName name, IBinder service) {
		LocalBinder  binder = (LocalBinder ) service;
		BusProvider = binder.getService();
		mBound = true;
		UpdateArrayOfBusses();
	}

	@Override
	public void onServiceDisconnected(ComponentName name) {
		mBound = false;	
	}
};
\end{lstlisting}
Alle funktionerne i TrackABusProvider klassen bliver afviklet i deres egen tråd for ikke at blokere main/UI tråden. For at TrackABusProvider funktionerne kan sende data rigtigt tilbage til den klasse der kaldte funktionen, bliver der brugt en Message Handler.
\\
På TrackABusProvider siden er dette blevet implementeret ved, at hver funktion tager imod en ReplyMessage og Handler som parameter. Når funktionen er færdig med at hente data fra SoapProvideren, bliver der oprettet en ny Message. Se \textit{afsnit 9.2.1 Implementering af persistens i mobilapplikationen} for information om, hvordan MySQL databasen bliver tilgået. Messagen sendes over den medfølgende Handler, som er implementeret i den klasse, der kaldte servicen. ReplyMessage beskriver overfor Handleren, hvad den er blevet færdig med, så Handleren kan udføre det korrekte arbejde med dataen. På kodeudsnit \ref{lst:GetBusRouteTrackABus} kan der ses et eksempel på en funktion i TrackABusProvider klassen. "GetbusRoute" tilgår SoapProvider klassen, for at hente en bestemt busrute, og alle de stoppesteder der hører til denne fra MySQL databasen. Data hentet herfra, bliver lagt i en ParcelableArrayList. Dette gør det muligt at sende custom datatyper med i de messages, der bliver sendt. Disse custom datatyper skal dog implementere Parcelable interfacet. Disse klasser kan ses på \ref{fig:AppKlasseDiagramModel}, under "Parcelable Modeller". Til sidst bliver der oprettet en ny Message, med den ReplyMessage der fulgte med som parameter, så Handleren ved hvilket arbejde den skal udføre. Denne message sendes til Handler parameteren.
\newpage
\begin{lstlisting}[caption=GetBusRoute() i TrackABusProvdider, language=JAVA, label={lst:GetBusRouteTrackABus}]
public void GetBusRoute(final String busNumber, final int ReplyMessage, final Handler replyTo){
try{
	new Thread(new Runnable() {
		public void run() {
			mMessenger = new Messenger(replyTo);
			Bundle b = new Bundle();
			ArrayList<BusRoute> arg0 = soapProvider.GetBusRoute(busNumber);
			ArrayList<BusStop> arg1 = soapProvider.GetBusStops(busNumber);
			b.putParcelableArrayList("BusRoute", arg0);
			b.putParcelableArrayList("BusStop", arg1);

			Message bMsg = Message.obtain(null, ReplyMessage, 0, 0);
			bMsg.setData(b);
			try {
			mMessenger.send(bMsg);
			} catch (RemoteException e) {
			e.printStackTrace();						
			}
	}}).start();
}
\end{lstlisting}
De klasser der er bundet til TrackABusProvideren skal implementere en Message Handler, der skal bruges i sammenhæng med kald til funktionerne i TrackABusProvideren. Denne Handler står for at modtage beskederne, når den kaldte TrackABusProvider funktion er færdig. For at kalde en af TrackABusProvider funktionerne skal der, som beskrevet ovenstående, altid medsendes en ReplyMessage og en Message Handler. Handler parameteren er den Message Handler der er oprettet i den klasse som kalder servicen. På kodeudsnit \ref{lst:msgHandler} vises Message Handleren i BusMapActivity. Når den modtager en besked, vil den undersøge hvilken ReplyMessage der ligger i beskeden. Dette gøres for at være sikker på, at data håndteret korrekt. For at få det data der bliver sendt med i beskeden, bliver "getData" kaldt på beskeden.
\newpage
\begin{lstlisting}[caption=msgHandler i BusMapActivity, language=JAVA, label={lst:msgHandler}]
final static public int BUS_ROUTE_DONE = 1;
final static public int BUS_POS_DONE = 2;
...
class msgHandler extends Handler{			
@Override
		public void handleMessage(Message msg) {				
			if(msg != null){
				switch(msg.what){
				case BUS_ROUTE_DONE:
					...
					ArrayList<BusRoute> BusRoutes = msg.getData().getParcelableArrayList("BusRoute");
					ArrayList<BusStop> BusStops = msg.getData().getParcelableArrayList("BusStop");
					...
				break;
				case BUS_POS_DONE:
					...
				break;
\end{lstlisting}
For at kunne indtegne ruterne, stoppestederne og busserne skal det være muligt at have et kort at tegne på. Hertil er der blevet brugt Google Maps.\footnote{Dette kan der læses mere om på \url{https://developers.google.com/maps/documentation/android/}} For at kunne bruge dette kort, kræves det at en API nøgle fra Google bliver tilføjet til manifestet. Denne kan anskaffes fra Googles API konsol\footnote{Denne tilgås igennem \url{https://code.google.com/apis/console}}.
\begin{lstlisting}[caption=API nøgle i manifest, language=XML, label={lst:APIManifest}]
<meta-data       
	android:name="com.google.android.maps.v2.API_KEY"
	android:value="AIzaSyC9qLxvm9yVIBJ5Dp0VqMapFvc4VLUlqu8"/> 
\end{lstlisting}
For at vise selve kortet, skal der laves en layout fil, som indeholder et mapFragment, som vist i kodeudsnit \ref{lst:mapFragment}. Det vil nu være muligt at se et kort i applikationen.
\newpage
\begin{lstlisting}[caption=mapFragment, language=XML, label={lst:mapFragment}]
<fragment
	android:id="@+id/map"
	android:layout_width="match_parent"
	android:layout_height="wrap_content"
	android:name="com.google.android.gms.maps.MapFragment"/>
\end{lstlisting}
Det er nu muligt at indtegne ruter, stoppesteder og busser på ruten, på dette fragment. Rute og bus relvant information hentes igennen TrackBusProvideren, og på kodeudsnit \ref{lst:Polyline} kan det ses, hvordan en rute tegnes. Ruten bliver tegnet ved brug af en Polyline, som opbygges af de koordinater der hentes fra MySQL databasen.
\begin{lstlisting}[caption=hvordan en Polyline bliver indtegnet på kortet, language=JAVA, label={lst:Polyline}]
PolylineOptions pOption = new PolylineOptions().width(10).color(0x66ff0000);
for(int i = 0; i < points.size(); i++){
	pOption.add(points.get(i).Position);
}
map.addPolyline(pOption);
\end{lstlisting}
Busstoppestederne bliver ligeså tegnet ind ved at bruge de GPS-koordinater, der er blevet hentet fra MySQL databasen. Disse koordinater bruges til at tegne markører på kortet. Der vil blive knyttet en ClickListener på alle markerne, som kaldes når et stoppested trykkes. Denne sørger for at starte tidsopdaterings funktionerne. På kodeudsnit \ref{lst:stoppestederMarkers} kan det ses, hvordan et stoppested tilføjes til kortet.
\begin{lstlisting}[caption=Hvordan stoppesteder bliver indtegnet på kortet, language=JAVA, label={lst:stoppestederMarkers}]
for(int i = 0; i<stops.size(); i++){
	map.addMarker(new MarkerOptions()
	.position(stops.get(i).Position.Position).title(stops.get(i).Name)
	.icon(BitmapDescriptorFactory.fromResource(R.drawable.teststop)));
}
\end{lstlisting}
BusListAdapteren er lavet til det formål, således at hvert list element i BusListMenuActivity, kan indeholde en togglebutton, en progressbar, foruden tekst. Dette gøres da favoriserings metoder også startes fra en af disse elementer.
\\
Mange steder i applikationen skal der bruges adgang til internettet, og der kan derfor forkomme fejl, hvis der ikke er tilgang hertil. Dette er blevet håndteret ved at implementere en BroadcastReceiver i klassen ConnectivityChecker, der abonnerer på,  ændringer i netværksforbindelsen for både wifi og mobilt data netværk. På kodeudsnit \ref{lst:ConnectivityChecker}, kan manifest filen ses, hvori det vises hvordan BroadcastReceiveren kobles til de nødvendige events. Når der sker et event undersøges der, om der er internet, og en statisk bool sættes til true hvis der er forbindelse, og false hvis der ikke er. Hertil er det muligt for applikationen til hver en tid at vide, om der er adgang til internettet.
\begin{lstlisting}[caption=ConnectivityChecker i manifest filen, language=JAVA, label={lst:ConnectivityChecker}]
        <receiver android:name="ConnectivityChecker">
            <intent-filter>
                <action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>
               	<action android:name="android.net.conn.WIFI_STATE_CHANGED"/>
            </intent-filter>
        </receiver>
\end{lstlisting}
\end{document}