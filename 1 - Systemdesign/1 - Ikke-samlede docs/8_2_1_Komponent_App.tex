\documentclass[Main.tex]{subfiles} 
\begin{document}
\subsubsection{Komponent 1: Mobil applikation}
Denne komponent har til formål at formidle alt bus information til brugeren. Den gør det muligt for brugeren at se busruter med stoppesteder indtegnet på et kort samt positionen for de busser der køre på ruten. Herudover vil det være muligt at se hvor lang tid der er til, at den næsten bus ankommer ved et valgt busstoppested. \\

\noindent
\textbf{Specifikationer}\\
På figur \ref{fig:AppKlasseDiagram} kan de forskellige klasser ses, samt hvilke lag de ligger i og hvordan de interagerer. Model klasser vises ikke som interageringer.
\\
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{./Diagrammer/Klassediagrammer/App_klasseDia.jpg}
	\caption{Klassediagram for mobil applikationen}
	\label{fig:AppKlasseDiagram}
\end{figure}
\newpage
\noindent
På figur \ref{fig:AppKlasseDiagramModel} ses de forskellige model klasser, der hovedsageligt består af custom datatyper.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{./Diagrammer/Klassediagrammer/App_klasseDia_models.jpg}
	\caption{Klassediagram for model klasser i mobil applikationen}
	\label{fig:AppKlasseDiagramModel}
\end{figure}

\noindent
Her følger en kort beskrivelse af hver klasse, samt den funktionalitet klassen tilføjer til systemet.
\begin{itemize}
	\item MainScreenActivity
	\begin{itemize}
		\item Denne klasse implementerer Activity interfacet, hvilket betyder, at den bruges som et view. Denne agerer som startskærm for applikationen, og lader brugeren vælge en favorit bus. Herfra kan brugeren desuden også vælge at åbne BusListMenuActivity.
	\end{itemize}
	\item BusListMenuActivity
	\begin{itemize}
		\item Denne klasse implementerer ListActivity interfacet, hvilket betyder, at den bruges som et view, men en list adapter kan sættes hertil. Den har til formål at præsentere brugeren for listen af ruter der eksisterer i MySQL databasen, samt favorisere en given rute. Selve viewet er bygget op med en adapter, hvori favoriserings funktionaliteten ligger, samt click eventet for favoriserings knappen. Selve klikket på et element fra listen, håndteres i BusListMenuActivity klassen. Herigennem har brugeren mulighed for at vælge en busrute, favoriseret såvel som ikke.
	\end{itemize}
	\item BusMapActivity
	\begin{itemize}
		\item Denne klasse implementerer Activity interfacet, hvilket betyder, at den bruges som et view. Den har til formål at præsentere brugeren for et kort med indtegnet valgt busrute og stoppesteder. Her vil kørende busser på ruten også præsenteres. Den har desuden til formål at starte tidsopdaterings funktionalitet, ved et tryk på et stoppested.
	\end{itemize}
	\item BusListAdapter
	\begin{itemize}
		\item Denne klasse implementerer Adapter interfacet, hvilket betyder, at den kan bruges til at repræsentere de layout-elementer der skal vises på viewet. I denne sammenhæng er den koblet til BusListMenuActivityet. Den har til formål at håndtere alle favoriserings funktionerne, og click eventet for favoriserings knappen. 
	\end{itemize}
	\item ConnectivityChecker
	\begin{itemize}
		\item Denne klasse implementerer BroadcastReceiver, hvilket betyder, at den modtager registrede system events. Disse events bliver sat i manifestet. I denne sammenhæng er den koblet til CONNECTIVITY\_CHANGE og\\ WIFI\_STATE\_CHANGED. Disse events omhandler ændringer i netværksforbindelse. Når der sker en ændring, undersøger den hvorvidt nettet kan tilgås, hvorefter den sætter en statisk bool til true hvis det kan tilgås, og false hvis ikke.
	\end{itemize}
	\item ContentProviderAcces
	\begin{itemize}
		\item Denne klasse er et abstraktions lag mellem præsentations laget og ContentProvideren, som ligger i data tilgangs laget. Dette betyder at det er den eneste klasse, som tilgår ContentProvideren. Funktionerne i denne klasse er statiske, da kun én indskrivnings- eller sletnings process kan udføres af gangen.
	\end{itemize}
	\item TrackABusProvider
	\begin{itemize}
		\item Denne klasse implementer Service interfacet, hvilket betyder at klassen kan tilgås som en Bound Service. Klassen agerer som et abstraktions lag mellem præsentations laget og SoapProvideren, som ligger i data tilgangs laget. Dette betyder, at den er den eneste klasse, som tilgår SoapProvideren. Funktionerne i denne klasse returnerer aldrig direte til det view som kaldte den, men i stedet over en MessageHandler. Dette gør at service funktionerne kan afvikles asynkront.
	\end{itemize}
	\item UserPrefProvider
	\begin{itemize}
		\item Denne klasse implementer ContentProvider interfacet, hvilket betyder at klassen kan tilgås igennem "getContentResolver" funktionen, hvis den er koblet til applikationen i manifestet. Denne klasse sørger for at tilgå den lokale SQLite database, for at persistere eller fjerne en favoriseret rute. Denne er således den ene klasse i data tilgangs laget. Der kommunikeres udelukkende med denne klasse igennem ContentProviderAcces klassen. 
	\end{itemize}
	\item SoapProvider
	\begin{itemize}
		\item Denne klasse har til formål at tilgå de forskellige funktioner i mobil servicen på serveren. Disse kald tilgår MySQL databasen, og er derfor den anden klasse i data tilgangs laget. Der kommunikeres udelukkende med denne klasse igennem TrackABusProvideren.
	\end{itemize}
	\item Parcelable modeller
	\begin{itemize}
		\item Disse klasser bruges som datatyper TrackABusProvideren. Disse har alle til fælles at de implementerer Parcelable. Dette gør det muligt for disse modeller at pakkes ned i en message, og sendes til en nessage handler.
	\end{itemize}
	\item ContentProvider modeller
	\begin{itemize}
		\item Disse klasser er modeller for de tabeller, SQLite databasen indeholder. De indeholder herunder navnene på de forskellige kolonner i tabellen, samt hvilken URI, der skal kaldes med, for at tilgå den givne tabel.
	\end{itemize}
	\item BusListAdapter modeller
	\begin{itemize}
		\item Disse klasser bruges i sammenhæng med at gemme de UI elementer, som bruges i BusListAdapteren, samt det data denne indeholder. 
	\end{itemize}
\end{itemize}
\newpage
\noindent
\textbf{Design:}\\
Applikationen er blevet udviklet til android mobiltelefoner som kører med OS version 4.3 Jelly Bean og op til 4.4 KitKat. Dertil er der blevet udviklet imod android API level 18 og 19.
\\
Mobil applikationen er udviklet med fokus på, at der skulle ske så lidt arbejde på telefonen som muligt. Alle tunge udregninger og processeringer sker på en webservice, \textit{Se afsnit 8.2.2 Komponent 2: Mobile service}
\\
For at kunne vise busruter, stoppesteder, busser og tid til ankomst, skal dette hentes fra en databasen. Til dette formål er der blevet lavet to klasser, TrackABusProvider og SoapProvider. TrackABusProvideren er udviklet som en BoundService, som både BuslistMenuActivity og BusMapActivity bruger. For at binde til TrackABusProvideren, bliver "startService" kaldt, som starter servicen, hvis den ikke allerede kører. Herefter vil funktionen "bindService" blive kaldt, som i dette tilfælde binder BuslistMenuActivity til TrackABusProvideren.
\begin{lstlisting}[caption=Binding til TrackABusProvider, language=JAVA]
if(ConnectivityChecker.hasInternet){
	Intent intent = new Intent(BuslistMenuActivity.this, TrackABusProvider.class);
	startService(intent);
	bindService(intent, Connection, Context.BIND_AUTO_CREATE);	
	}
\end{lstlisting}
Denne binding vil ske asynkront, og det er derfor ikke muligt at vide, hvornår den er færdig. Til dette formål bruges en ServiceConnection. Denne har en callback function, "onServiceConnected", der vil blive kaldt så snart der er blevet bundet til servicen. For at sikre at de funktioner, som kræver en bundet service, først bliver kaldt når dette er opfyldt, bliver kaldt i onServiceConnected. "getService" vil initialisere en instans af den service der er bliver bundet til, og herfra vil det være muligt at kalde de forskellige service funktioner, der er implementeret i TrackABusProvider klassen.
\begin{lstlisting}[caption=ServiceConnection i BuslistMenuActivity, language=JAVA]
private ServiceConnection Connection = new ServiceConnection(){			
	@Override
	public void onServiceConnected(ComponentName name, IBinder service) {
		LocalBinder  binder = (LocalBinder ) service;
		BusProvider = binder.getService();
		mBound = true;
		UpdateArrayOfBusses();
	}

	@Override
	public void onServiceDisconnected(ComponentName name) {
		mBound = false;	
	}
};
\end{lstlisting}
Alle funktionerne i TrackABusProvider klassen bliver afviklet i deres egen tråd for ikke at blokere main/UI tråden. For at TrackABusProvider funktionerne kan sende data rigtigt tilbage til den klasse der kaldte funktionen, bliver der brugt en Message Handler.
\\
På TrackABusProvider siden er dette blevet implementeret ved, at hver funktion tager imod en ReplyMessage og Handler som parameter. Når funktionen er færdig med at hente data fra SoapProvideren, bliver der oprettet en ny Message. Se \textit{afsnit 9.2.1 Implementering af persistens i mobilapplikationen} for information om, hvordan MySQL databasen bliver tilgået. Messagen sendes over den medfølgende Handler, som er implementeret i den klasse, der kaldte servicen. ReplyMessage beskriver overfor Handleren, hvad den er blevet færdig med, så Handleren kan udføre det korrekte arbejde med dataen. På kodeudsnit \ref{lst:GetBusRouteTrackABus} kan der ses et eksempel på en funktion i TrackABusProvider klassen. "GetbusRoute" tilgår SoapProvider klassen, for at hente en bestemt busrute, og alle de stoppesteder der hører til denne fra MySQL databasen. Data hentet herfra, bliver lagt i en ParcelableArrayList. Dette gør det muligt at sende custom datatyper med i de messages, der bliver sendt. Disse custom datatyper skal dog implementere Parcelable interfacet. Disse klasser kan ses på figur \ref{fig:AppKlasseDiagramModel}, under "Parcelable Modeller". Til sidst bliver der oprettet en ny Message, med den ReplyMessage der fulgte med som parameter, så Handleren ved hvilket arbejde den skal udføre. Denne message sendes til Handler parameteren.
\newpage
\begin{lstlisting}[caption=GetBusRoute() i TrackABusProvdider, language=JAVA, label={lst:GetBusRouteTrackABus}]
public void GetBusRoute(final String busNumber, final int ReplyMessage, final Handler replyTo){
try{
	new Thread(new Runnable() {
		public void run() {
			mMessenger = new Messenger(replyTo);
			Bundle b = new Bundle();
			ArrayList<BusRoute> arg0 = soapProvider.GetBusRoute(busNumber);
			ArrayList<BusStop> arg1 = soapProvider.GetBusStops(busNumber);
			b.putParcelableArrayList("BusRoute", arg0);
			b.putParcelableArrayList("BusStop", arg1);

			Message bMsg = Message.obtain(null, ReplyMessage, 0, 0);
			bMsg.setData(b);
			try {
			mMessenger.send(bMsg);
			} catch (RemoteException e) {
			e.printStackTrace();						
			}
	}}).start();
}
\end{lstlisting}
De klasser der er bundet til TrackABusProvideren skal implementere en Message Handler, der skal bruges i sammenhæng med kald til funktionerne i TrackABusProvideren. Denne Handler står for at modtage beskederne, når den kaldte TrackABusProvider funktion er færdig. For at kalde en af TrackABusProvider funktionerne skal der, som beskrevet ovenstående, altid medsendes en ReplyMessage og en Message Handler. Handler parameteren er den Message Handler der er oprettet i den klasse som kalder servicen. På kodeudsnit \ref{lst:msgHandler} vises Message Handleren i BusMapActivity. Når den modtager en besked, vil den undersøge hvilken ReplyMessage der ligger i beskeden. Dette gøres for at være sikker på, at data håndteret korrekt. For at få det data der bliver sendt med i beskeden, bliver "getData" kaldt på beskeden.
\newpage
\begin{lstlisting}[caption=msgHandler i BusMapActivity, language=JAVA, label={lst:msgHandler}]
final static public int BUS_ROUTE_DONE = 1;
final static public int BUS_POS_DONE = 2;
...
class msgHandler extends Handler{			
@Override
		public void handleMessage(Message msg) {				
			if(msg != null){
				switch(msg.what){
				case BUS_ROUTE_DONE:
					...
					ArrayList<BusRoute> BusRoutes = msg.getData().getParcelableArrayList("BusRoute");
					ArrayList<BusStop> BusStops = msg.getData().getParcelableArrayList("BusStop");
					...
				break;
				case BUS_POS_DONE:
					...
				break;
\end{lstlisting}
For at kunne indtegne ruterne, stoppestederne og busserne skal det være muligt at have et kort at tegne på. Hertil er der blevet brugt Google Maps.\footnote{Dette kan der læses mere om på \url{https://developers.google.com/maps/documentation/android/}} For at kunne bruge dette kort, kræves det at en API nøgle fra Google bliver tilføjet til manifestet. Denne kan anskaffes fra Googles API konsol\footnote{Denne tilgås igennem \url{https://code.google.com/apis/console}}.
\begin{lstlisting}[caption=API nøgle i manifest, language=XML, label={lst:APIManifest}]
<meta-data       
	android:name="com.google.android.maps.v2.API_KEY"
	android:value="AIzaSyC9qLxvm9yVIBJ5Dp0VqMapFvc4VLUlqu8"/> 
\end{lstlisting}
For at vise selve kortet, skal der laves en layout fil, som indeholder et mapFragment, som vist i kodeudsnit \ref{lst:mapFragment}. Det vil nu være muligt at se et kort i applikationen.
\newpage
\begin{lstlisting}[caption=mapFragment, language=XML, label={lst:mapFragment}]
<fragment
	android:id="@+id/map"
	android:layout_width="match_parent"
	android:layout_height="wrap_content"
	android:name="com.google.android.gms.maps.MapFragment"/>
\end{lstlisting}
Det er nu muligt at indtegne ruter, stoppesteder og busser på ruten, på dette fragment. Rute og bus relvant information hentes igennen TrackBusProvideren, og på kodeudsnit \ref{lst:Polyline} kan det ses, hvordan en rute tegnes. Ruten bliver tegnet ved brug af en Polyline, som opbygges af de koordinater der hentes fra MySQL databasen.
\begin{lstlisting}[caption=hvordan en Polyline bliver indtegnet på kortet, language=JAVA, label={lst:Polyline}]
PolylineOptions pOption = new PolylineOptions().width(10).color(0x66ff0000);
for(int i = 0; i < points.size(); i++){
	pOption.add(points.get(i).Position);
}
map.addPolyline(pOption);
\end{lstlisting}
Busstoppestederne bliver ligeså tegnet ind ved at bruge de GPS-koordinater, der er blevet hentet fra MySQL databasen. Disse koordinater bruges til at tegne markører på kortet. Der vil blive knyttet en ClickListener på alle markerne, som kaldes når et stoppested trykkes. Denne sørger for at starte tidsopdaterings funktionerne. På kodeudsnit \ref{lst:stoppestederMarkers} kan det ses, hvordan et stoppested tilføjes til kortet.
\begin{lstlisting}[caption=Hvordan stoppesteder bliver indtegnet på kortet, language=JAVA, label={lst:stoppestederMarkers}]
for(int i = 0; i<stops.size(); i++){
	map.addMarker(new MarkerOptions()
	.position(stops.get(i).Position.Position).title(stops.get(i).Name)
	.icon(BitmapDescriptorFactory.fromResource(R.drawable.teststop)));
}
\end{lstlisting}
BusListAdapteren er lavet til det formål, således at hvert list element i BusListMenuActivity, kan indeholde en togglebutton, en progressbar, foruden tekst. Dette gøres da favoriserings metoder også startes fra en af disse elementer.
\\
Mange steder i applikationen skal der bruges adgang til internettet, og der kan derfor forkomme fejl, hvis der ikke er tilgang hertil. Dette er blevet håndteret ved at implementere en BroadcastReceiver i klassen ConnectivityChecker, der abonnerer på,  ændringer i netværksforbindelsen for både wifi og mobilt data netværk. På kodeudsnit \ref{lst:ConnectivityChecker}, kan manifest filen ses, hvori det vises hvordan BroadcastReceiveren kobles til de nødvendige events. Når der sker et event undersøges der, om der er internet, og en statisk bool sættes til true hvis der er forbindelse, og false hvis der ikke er. Hertil er det muligt for applikationen til hver en tid at vide, om der er adgang til internettet.
\begin{lstlisting}[caption=ConnectivityChecker i manifest filen, language=JAVA, label={lst:ConnectivityChecker}]
        <receiver android:name="ConnectivityChecker">
            <intent-filter>
                <action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>
               	<action android:name="android.net.conn.WIFI_STATE_CHANGED"/>
            </intent-filter>
        </receiver>
\end{lstlisting}
\end{document}